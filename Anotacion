while--------)______No sabemos la cantidad
do...while---)

for------> Sabemos la cantidad

Contador:
variable=variable+k; donde k es una constante

Acumulador:
variable=variable+variable2;

solamente se usa fflush(stdin); cuando lo que tengo siguiente es un %c o %s. Para limpiar el buf de espera de variables char
Si no lo uso y apreto Enter queda esperando a la proxima variable char.

Funciones
con retorno:

int suma(int operando1, int operando2){ //recibe variables
    int resultado;
    resultado=operando1+operando2;
    return resultado; //retorno el resultado
    }

Para usar la funcion:
#include <stdio.h>
#include <stdlib.h>
int suma(int, int); //prototipo o declaracion
int main()
{


    int nro1,nro2,res;
    printf("num1: ");
    scanf("%d",&nro1);
    printf("num2: ");
    scanf("%d",&nro2);
    res=suma(nro1, nro2); //aca llamo a la funcion
    printf("La suma es :%d",res);

    return 0;
}
-----------------------------------------

Que hace?
Que retorna?
Que recibe?


Para nombrar las funciones no se puede utilizar palabras reservadas

¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡Todos los martes parcialito!!!!!!!!!!!!!!!!!!!!!!!!!!!


Entrega de TP 7 de sep hasta las 23:59

En dos variables con mismo nombre, la prioridad es para la variable local antes que la global

Puntero:
int *ptr;
ptr=%var;-----> tomo la direccion de memoria
*ptr ----> DATO guardado en la direccion de memoria

Se usa tambien para devolver una cadena con char*


-------------------------------------------

Array cuando los puntos son iguales y hay que comparar la diferencia de goles
int pts[5], auxPts;
int dg[5], auxdg;

	[1] [0] [3] [3] [1]
	[8] [10] [5] [3] [4]
indice:  0   1    2   3   4

for (i=0;i<5-1;i++){
	for(j=i+1;j<5;j++){
	if(pts[i]<pts[j]){
		auxPts
		}
	
	}
}


Cadena de caracteres (String):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯

['h']['o']['l']['a']['\0']['']['']['']
  0    1    2    3     4    5   6   7

No hay que preocuparse por el \0 por que cuando imprima va a cortar donde corta la cadena

Se puede incluir la funcion string.h

strcpy(destino, origen);

El origen puede ser una variable, una constante o puede ser literal entre "comillas"

El destino tiene que ser una variable






%d Imprime un número entero
%f Imprime un número con decimales
%c Imprime un caracter
%s Imprime un array de caracteres


gets


cantidad=strlen(nombre); //devuelve la cantidad de caracteres pero tambien devuelve los espacios

['J']['u']['a']['n'][' ']['P']['a']['b']['l']['o']['\n']['\0']
  0    1    2    3    4    5    6    7    8    9    10

fgets (cadena,cantidad,stdin);
si tomo el dato con fgets el enter va a ser un caracter mas y va a devolver 11

Para que devuelva 10 y no 11 hacemos:

char buffer[64];
fgets(buffer,sizeof(buffer)-2,stdin); //le resto 2 por que sizeof(buffer) lee los bytes o caracteres de buffer, va a leer 64

cantidad = strlen(buffer); //devuelve la cantidad de caracteres a la variable cantidad

buffer[cantidad-1] = '\0'; //le resto 1 para posicionarse antes del \0, luego almacena en esa posicion el \n

printf("%s", buffer);

------------------------------------------------

strcat (apeNom," "); //lo uso para concatenar

usando la biblioteca #include <string.h>:
strlwr(nombre); //pasa todo a minuscula, si esta en minuscula lo deja asi, si esta en mayuscula lo pasa todo a minuscula

strupl(nombre); //lo mismo que antes pero todo a mayuscula


#include <ctype.h>
tolower //pasa a minuscula un solo caracter
toupper //pasa a mayuscula un solo caracter
nombre[0]=toupper(nombre[0]);

Hacer
la inicial en mayuscula y el resto todo en minuscula


